package other.O004.answer;

/**
 * 약수를 찾을 때 주어진 숫자의 제곱근까지만 확인하면 모든 약수를 찾을 수 있다.
 * 예를 들어, 36의 약수는 1, 2, 3, 4, 6, 9, 12, 18, 36이다.
 * 여기서 36의 제곱근은 6이며, 6 이하의 약수는 1, 2, 3, 4, 6이고, 이들의 짝꿍인 36, 18, 12, 9, 6은 6 이상의 약수들이다.
 * <p>
 * 따라서 제곱근까지의 루프를 돌려 약수를 구한다.
 * 이 때 약수가 출현했을 시
 * 10000과 99999사이면 카운트를 1 올린다.
 * 또한 검사를 하려는 수와 약수를 나눴을 시 10000과 99999사이 그리고 나눈 몫과 다른 경우는 약수의 짝궁이기 때문에 카운트 1을 또 해준다.
 * ※여기서 몫과 같은 경우를 제외 하는 이유는 4의 약수가 1 2 4인 경우 2가 두번 칸운트되는 것을 방지하기 위함이다.
 * 최종적으로 카운트를 출력한다.
 */

public class A1 {
    public static void main(String[] args) {
        long num = 1005404400L; // 검사하려는 수
        int count = 0; // 약수의 개수를 저장할 변수
        int sqrt = (int) Math.sqrt(num); // 검사하려는 수의 제곱근

        // 1부터 제곱근까지의 수에 대해
        for (int i = 1; i <= sqrt; i++) {
            // 만약 i가 num의 약수라면
            if (num % i == 0) {
                // i가 10000 이상 99999 이하라면 카운트 증가
                if (i >= 10000 && i <= 99999) {
                    count++;
                }
                // i로 num을 나눈 몫을 구하고
                long quotient = num / i;
                // 몫과 i가 다르면서 몫이 10000 이상 99999 이하라면 카운트 증가
                // 몫과 i가 다른 경우는 제곱근이 정수가 아닌 경우로, 이 때만 몫과 i가 다르게 됩니다.
                if (quotient != i && quotient >= 10000 && quotient <= 99999) {
                    count++;
                }
            }
        }

        // 결과 출력
        System.out.println("Count of divisors in range 10000 to 99999: " + count);
    }
}
